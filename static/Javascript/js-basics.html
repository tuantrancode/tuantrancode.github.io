<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript - Basics</title>
    <link rel="stylesheet" href="/common-styles.css">
    <link rel="stylesheet" href="/main-layout.css">
    <script type="module">
        import { loadMenu, getTheme } from '/load-menu.js';

        getTheme();
        loadMenu("mainContainer", "rightNav");
    </script>
</head>

<body>
    <!-- Main Container -->
    <div class="container" id="mainContainer">

        <!-- Main Content -->
        <div class="main-content" id="mainContent">

            <!-- JS FIDDLE -->
            <h3 class="section-header" id="jsFiddle">JS Fiddle</h3>
            <p><a href="https://jsfiddle.net/" target="_blank">JS Fiddle</a> is a useful site to test out HTML, CSS, and
                Javascript snippets.</p>
            <hr>

            <!-- BACKTICK AND STRING-->
            <h3 class="section-header" id="backtick">Backtick & String</h3>
            <pre><code class="language-javascript">const embeddedExpression = `Current Year: ${new Date().getFullYear()}`;</code></pre>
                  <ul>
                <li>Use backticks ` in order to create a <strong>template literal</strong> string - string in Javascript that spans
                    multiple lines and uses embedded expression ( i.e. ${variableName} )</li>
    
            </ul>
            <hr>

            <!-- COMMENTS -->
            <h3 class="section-header" id="comment">Comments</h3>
            <pre><code class="language-javascript">// This line is a comment

/*
This block is also a comment
*/ </code></pre>
            <hr>

            <!-- CONSOLE LOG -->
            <h3 class="section-header" id="consoleLog">Console Log</h3>
            <pre><code class="language-javascript"><mark>console.log</mark>("message");
try{
   // do something
} catch (e) {
   <mark>console.error</mark>("Do something failed: ", e.message)
} finally {
   console.log("Do something finished!")
} </code></pre>
            <hr>

            <!-- VARIABLES -->
            <h3 class="section-header" id="variables">Variables</h3>
            <ul>
                <li><code>const</code>: declare constant; can't be reassign</li>
                <li><code>let</code>: declare declare block-scoped variables</li>
                <li><code>var</code>: avoid in modern code; delcare function-scoped variables (accessible even behond
                    <code>if</code> and <code>for</code> loops statements)
                </li>
                <li><code>${variableName}</code>: allow for clean injecting of Javascript variables/ expressions into
                    the middle of string without having to <code>variableName + " string literal"</code></li>
                <ul>
                    <li>Only usuable in a String</li>
                </ul>
            </ul>
            <hr>


            <!-- TYPES -->
            <h3 class="section-header" id="types">Variable Types</h3>
            <ul>
                <li><code>string</code>: "hello"
                <li><code>number</code>: 5</li>
                <li><code>boolean</code>: true</li>
                <li><code>object</code>: { key: value }, [1, 2, 3], /regex/, new Date()</li>
                <li><code>function</code>: function () {}, class MyClass {}</li>
                <li><code>bigint</code>: 9007199254740992</li>
                <ul>
                    <li><code>MAX_SAFE_NUMBER</code> = 9007199254740991</li>
                </ul>
                <li><code>symbol</code>: <code>Symbol(x)</code></li>
                <li><code>undefined</code>: a variable that has not been assigned a value</li>

            </ul>
            <h4 class="sub-section-header">Unconventional Cases</h4>
            <pre><code class="language-javascript">// Numbers
typeof NaN === "number"; // Despite being "Not-A-Number"
typeof Number("shoe") === "number"; // Number tries to parse things into numbers

// Strings
typeof typeof 1 === "string"; // typeof always returns a string
typeof String(1) === "string"; // String converts anything into a string, safer than toString

// Booleans
typeof Boolean(1) === "boolean"; // Boolean() will convert values based on if they're truthy or falsy
typeof !!1 === "boolean"; // two calls of the ! (logical NOT) operator are equivalent to Boolean()

// Objects
typeof null === "object"; // null is also treated as false and 0;

// Avoid
typeof new Boolean(true) === "object";
typeof new Number(1) === "object";
typeof new String("abc") === "object";</code></pre>
            <h4 class="sub-section-header">Notes</h4>
            <ul>
                <li><code>typeof</code> can be used to identify type</li>
            </ul>
            <hr>


            <!-- DATA STRUCTURES -->
            <h3 class="section-header" id="dataStructures">Data Structures</h3>

            <table class="datastructures-table">
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Array</th>
                        <th>Object</th>
                        <th>Set</th>
                        <th>Map</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Type of keys:</strong></td>
                        <td>Numeric indexes (0,1,2...)</td>
                        <td>Strings or Symbols</td>
                        <td>Values only (no keys)</td>
                        <td>Any value (objects, functions, primitives)</td>
                    </tr>
                    <tr>
                        <td><strong>Allows duplicate values:</strong></td>
                        <td>Yes</td>
                        <td>N/A (keys must be unique)</td>
                        <td>No (all values are unique)</td>
                        <td>Keys unique, values can duplicate</td>
                    </tr>
                    <tr>
                        <td><strong>Order guaranteed:</strong></td>
                        <td>Yes (insertion order)</td>
                        <td>No (property order is mostly insertion-based but not reliable for all cases)</td>
                        <td>Yes (insertion order)</td>
                        <td>Yes (insertion order)</td>
                    </tr>
                    <tr>
                        <td><strong>Iteration support:</strong></td>
                        <td><code>for, for...of, forEach, map, filter, reduce</code></td>
                        <td><code>for...in, Object.keys/values/entries</code></td>
                        <td><code>for...of, forEach</code></td>
                        <td><code>for...of, forEach</code></td>
                    </tr>
                    <tr>
                        <td><strong>Primary use case:</strong></td>
                        <td>Ordered list of values</td>
                        <td>Key-value pairs, fast property lookup</td>
                        <td>Unique values collection</td>
                        <td>Key-value pairs with any key type</td>
                    </tr>
                    <tr>
                        <td><strong>Performance for lookups:</strong></td>
                        <td>O(1) by index</td>
                        <td>O(1) by key (hash map under the hood)</td>
                        <td>O(1) for presence checks</td>
                        <td>O(1) for presence checks</td>
                    </tr>
                    <tr>
                        <td><strong>Common methods:</strong></td>
                        <td><code>push, pop, map, filter, reduce</code></td>
                        <td><code>Object.keys, Object.values, hasOwnProperty</code></td>
                        <td><code>add, delete, has, clear</code></td>
                        <td><code>set, get, has, delete, clear</code></td>
                    </tr>
                </tbody>
            </table>
            <h4 class="sub-section-header">Notes</h4>
            <ul>
                <li><code>Array</code> is best for ordered lists and sequential data.</li>
                <li><code>Object</code> is the traditional key-value structure, but keys are limited to strings/symbols.
                </li>
                <li><code>Set</code> ensures uniqueness, useful for deduplication.</li>
                <li><code>Map</code> is more flexible than objects since keys can be any type.</li>
            </ul>
            <hr>


            <!-- OPERATORS -->
            <h3 class="section-header" id="operators">Operators</h3>
            <ul>
                <li><code>%</code>: remainder operator</li>
                <li><code>**</code>: expnentiation (i.e. ^)</li>
                <li><code>&&</code>: AND</li>
                <li><code>||</code>: OR</li>
                <li><code>!</code>: NOT</li>
                <li><code>===</code>(preferred): strict equality; both sides has to match values AND types (i.e. 5
                    ==
                    "5" is false)</li>
                <li><code>==</code>: loose equality; both sides only has to match values (i.e. 5 == "5" is true)
                </li>
            </ul>
            <hr>

            <!-- CONDITIONALS -->
            <h3 class="section-header" id="conditionals">Conditionals</h3>
            <ul>
                <li>if-else</li>
                <li> switch-case:
                    <pre><code class="language-javascript">switch () { 
    case <em>constant</em>: 
        // do something
        break; 
    default: 
} </code></pre>
                </li>
                <li>ternary: <code>const msg = (n > 5) ? "big" : "small";</code></li>
            </ul>
            <hr>

            <!-- LOOPS -->
            <h3 class="section-header" id="conditionals">Loops</h3>
            <ul>
                <li>for-loop</li>
                <li>while-loop</li>
                <li>for-loop with (arrays, iterables):
                    <code>for (const v of ["a","b","c"]) { console.log(v); }</code>
                </li>
                <li>for-loop with (key-value objects):
                    <code>for (const key in obj) { console.log(key, obj[key]); }</code>
                </li>
            </ul>
            <hr>

            <!-- CLASSES -->
            <h3 class="section-header" id="classes">Classes</h3>
            <p>Same as Java classes</p>
            <pre><code class="language-javascript">class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    return `${this.name} makes a noise.`;
  }
}

class Dog extends Animal {
  speak() {
    return `${this.name} barks.`;
  }


const d = new Dog("Rex");</code></pre>
            <hr>

            <!-- IMPORTING -->
            <h3 class="section-header" id="importing">Importing</h3>
            <p>>> An alias can be used to replace really long names by using <code>as</code> (i.e.
                <code>import {reallyLongName as newName} from "script.js" </code>)>
            </p>
            <ul>
                <li><strong>Named Import</strong>: import any exported Javascript bindings (i.e. functions,
                    variables/constants, classes, objects)</li>
                <pre><code class="language-javascript">//In script2.js
<mark>import {myFunction, MyClass} from "script1.js";</mark>

myFunction();
const v = new MyClass();
------------------------------------------------
//In script1.js
export function myFunction{}
export class MyClass{}</code></pre>
                <li><strong>Default Import</strong>: import any exported default Javascript bindings</li>
                <ul>
                    <li>Only one default can exist in each Javascript file</li>
                </ul>
                <ul>
                    <li>Any new alias can be given to the default</li>
                </ul>
                <pre><code class="language-javascript">//In script2.js
<mark>import NewNameClass from "script1.js";</mark>

const v = new NewNameClass();
------------------------------------------------
//In script1.js
export default class MyClass{}</code></pre>
                <li><strong>Namespace Import</strong>: import ALL exported Javascript bindings</li>
                <pre><code class="language-javascript">//In script2.js
<mark>import * as myModule from "script1.js";</mark>

myModule.myFunction();
const v = new myModule.NewNameClass();
------------------------------------------------
//In script1.js
export function myFunction{}
export class MyClass{}</code></pre>
                <li><strong>Side Effect Import</strong>: doesn't import anything, but instead run all the global
                    code of
                    the module</li>
                <pre><code class="language-javascript">//In script2.js
<mark>import "script1.js";</mark>

//myFunction is being run from the script2.js
------------------------------------------------
//In script1.js
export function myFunction{}
myFunction();</code></pre>
            </ul>
            <hr>


            <!-- IMPORTING INTO HTML -->
            <h3 class="section-header" id="importingIntoHTML">Importing into HTML</h3>
            <p>The section in <a href="/index.html#linkingJS"> <strong>HTML Basics</strong></a> covered it.</p>


        </div> <!-- Main Content End -->



        <!-- Table of Contents -->
        <div class="right-nav" id="rightNav">
            <h3>Table of Contents</h3>
            <a href="#jsFiddle">JS Fiddle</a>
            <a href="#backtick">Backtick & String</a>
            <a href="#comment">Comments</a>
            <a href="#consoleLog">Console Log</a>
            <a href="#variables">Variables</a>
            <a href="#types">Variable Types</a>
            <a href="#dataStructures">Data Structures</a>
            <a href="#operators">Operators</a>
            <a href="#conditionals">Conditionals</a>
            <a href="#loops">Loops</a>
            <a href="#classes">Classes</a>
            <a href="#importing">Importing</a>
            <a href="#importingIntoHTML">Importing into HTML</a>
        </div>
    </div> <!-- Main Container End -->

</body>

</html>